---
title: "brandon_scratch"
author: "Brandon Mannion"
date: "11/27/2018"
output: html_document
---

# PSEUDO / MISC.
- implement tangent (derivative-based) adaptive rejection sampler
- INPUTS: sample number
- check density
- check log concave density
- generate enveloping function
- squeezing function
- from sample number, do loop
  - etc. etc. 

## initial error-checking
- check input domain, D
- check input k, the number of xs to derive tangent
- check input g(x) , it's log form, log-concave, differentiable, etc.
- check input n, the number of values to sample

# CODE

## load libraries
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(assertthat)
library(numDeriv)
```
  
## dummy variables
```{r}
x <- seq(-10, 10, by=0.01)

# log-concave example
h <- function(x) {
  return(2*x - 10*log(1 + exp(x)) - 0.5*x^2 + 50)
}

# log-concave example
h <- function(x) {
        return(log(dnorm(x))) 
}

# NOT log-concave
h <- function(x) {
        return(exp(x))    
}
```

## FUNCTION
## .. intersection of tangent lines for x_{j} and x_{j+1}
## ... vectorize z code
```{r}
get_z <- function(j, x, h) {
        
        # EQUATION 1
        # z_{j} = h(x_{j+1}) - h(x_j) - x_{j+1} h'(x_{j+1}) + x_j h'(x_j)
        # ....... -----------------------------------------------------
        # .......                h'(x_j) - h'(x_{j+1})
        # END EQUATION 1

         # get h(x[j]) and h'(x[j])
        
        h_xj <- h(x[j])
        h_prime_xj <- grad(h,x[j])
        
        h_xjnext <- h(x[j+1])
        h_prime_xjnext <- grad(h, x[j+1])
  
        z_numerator <- h_xjnext - h_xj - ( x[j+1] * h_prime_xjnext ) + (x[j] * h_prime_xj)
        z_denominator <- h_prime_xj - h_prime_xjnext
        
        z_result <- z_numerator / z_denominator 
        
        ## ASSERTION 
        ## .. check that obtained z intersection is within x
        assert_that(z_result > x[1] && z_result < x[length(x)], msg = "z intersection is outside of X")
       
        return(z_result) 
        #return(list( z_numerator / z_denominator ))
}
```

## FUNCTION
## ... get all z for all X from 1 to k-1
```{r}
get_z_all <- function(x, h, D) {
       return(unlist(lapply(1:(length(x) - 1), get_z, x, h)))
}
```

## FUNCTION 
## ... check log concavity of function
```{r}
check_log_concave <- function(j,x,h) {
        
        get_u_integral <- function() {
                uj <- function(t) {
                    tmp_u <- get_u_segment(j,x,h)
                    return(tmp_u$intercept + tmp_u$slope*t)
                }
                fun <- function(t) { exp(uj(t)) }
                return(integrate(fun, x[j], x[j+1])$value)
        }
        u_integral <- get_u_integral()
        
        get_h_integral <- function() {
                return(integrate(h, x[j], x[j+1])$value)
        }
        h_integral <- get_h_integral()
        
        cat("u_integral: ", u_integral, "\nh_integral: ", h_integral, "\n")
        cat(ifelse(u_integral > h_integral, "upper bound segment > h(x)\n" , "ERROR upper bound segment < h(x)\n"))
        cat("\n\n")
        get_l_integral <- function() {
                lj <- function(t) {
                        tmp_l <- get_l_segment(j,x,h)
                        return(tmp_l$intercept + tmp_l$slope*t)
                }
                
                fun <- function(t) { exp(lj(t)) }
                return(integrate(fun, x[j], x[j+1])$value)
        }
        l_integral <- get_l_integral()
        
       cat("l_integral: ", l_integral, "\nh_integral: ", h_integral, "\n")
       cat(ifelse(l_integral < h_integral, "lower bound segment < h(x)\n" , "ERROR lower bound segment > h(x)\n"))
        
        # #################################################
        # integrate u(x) over x_initial and x_next -> I_u(x)
        # integrate h(x) over x_initial and x_next -> I_h(x)
        # integrate l(x) over x_initial and x_next -> I_l(x)
        # check if I_u(x) > I_h(x)
        # check if I_l(x) < I_h(x)
        # ##################################################
        # u(x_delta) > h(x_delta) ? 
        # l(x_delta) < h(x_delta) ? 
        # get_u_segment
        # get_l_segment
}
```