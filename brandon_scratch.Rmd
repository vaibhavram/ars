---
title: "brandon_scratch"
author: "Brandon Mannion"
date: "11/27/2018"
output: html_document
---

# PSEUDO / MISC.
- implement tangent (derivative-based) adaptive rejection sampler
- INPUTS: sample number
- check density
- check log concave density
- generate enveloping function
- squeezing function
- from sample number, do loop
  - etc. etc. 

## initial error-checking
- check input domain, D
- check input k, the number of xs to derive tangent
- check input g(x) , it's log form, log-concave, differentiable, etc.
- check input n, the number of values to sample

# CODE

## load libraries
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(assertthat)
library(numDeriv)
```
  
## dummy variables
```{r}
# borrowed setup from vaibhav_scratch.R
x <- -3:3

h <- function(x) {
  return(2*x - 10*log(1 + exp(x)) - 0.5*x^2 + 50)
}
```

## FUNCTION
## .. intersection of tangent lines for x_{j} and x_{j+1}
## ... vectorize z code
```{r}
get_z <- function(j, x, h) {
        
        # EQUATION 1
        # z_{j} = h(x_{j+1}) - h(x_j) - x_{j+1} h'(x_{j+1}) + x_j h'(x_j)
        # ....... -----------------------------------------------------
        # .......                h'(x_j) - h'(x_{j+1})
        # END EQUATION 1

         # get h(x[j]) and h'(x[j])
        
        h_xj <- h(x[j])
        h_prime_xj <- grad(h,x[j])
        
        h_xjnext <- h(x[j+1])
        h_prime_xjnext <- grad(h, x[j+1])
  
        z_numerator <- h_xjnext - h_xj - ( x[j+1] * h_prime_xjnext ) + (x[j] * h_prime_xj)
        z_denominator <- h_prime_xj - h_prime_xjnext
        return(list( z_numerator / z_denominator ))
}
```

## FUNCTION
## ... get all z for all X from 1 to k-1
```{r}
get_z_all <- function(x, h, D) {
       return(unlist(lapply(1:(length(x) - 1), get_z, x, h)))
}
```

## FUNCTION 
## ... check log concavity of function
```{r eval=FALSE}
# u(x_delta) > h(x_delta) ? 
# l(x_delta) < h(x_delta) ? 

# get_u_segment
# get_l_segment
check_log_concave <- function(x,u,l,h) {
        get x_initial
        get x_next
        integrate u(x) over x_initial and x_next -> I_u(x)
        integrate h(x) over x_initial and x_next -> I_h(x)
        integrate l(x) over x_initial and x_next -> I_l(x)
        check if I_u(x) > I_h(x)
        check if I_l(x) < I_h(x)
}
```